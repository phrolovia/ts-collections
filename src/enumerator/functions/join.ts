import type { EqualityComparator } from "../../shared/EqualityComparator";
import type { JoinSelector } from "../../shared/JoinSelector";
import type { Selector } from "../../shared/Selector";
import { from } from "./from";
import type { IEnumerable } from "../IEnumerable";

/**
 * Produces a projection from the sequence and a second sequence by matching elements that share an identical join key.
 * @template TElement Type of elements within the outer sequence.
 * @template TInner Type of elements within the inner sequence.
 * @template TKey Type of key produced by the key selectors.
 * @template TResult Type of element returned by {@link resultSelector}.
 * @param source The outer sequence.
 * @param innerEnumerable Sequence whose elements are joined with the outer sequence.
 * @param outerKeySelector Selector that extracts the join key from each outer element.
 * @param innerKeySelector Selector that extracts the join key from each inner element.
 * @param resultSelector Projection that combines an outer element with a matching inner element. When {@link leftJoin} is `true` and no match exists, `null` is supplied as the inner value.
 * @param keyComparator Optional equality comparator used to match keys. Defaults to the library's standard equality comparison when omitted.
 * @param leftJoin When `true`, outer elements with no matching inner element are included once with `null` provided to {@link resultSelector}. Defaults to `false` (inner join).
 * @returns {IEnumerable<TResult>} A sequence generated by applying {@link resultSelector} to each matching pair (and unmatched outer elements when {@link leftJoin} is enabled).
 * @remarks The inner sequence is fully enumerated to build an in-memory lookup before outer elements are processed. The outer sequence is then enumerated lazily and its original ordering is preserved.
 * @example
 * ```typescript
 * const categories = [
 *   { id: 1, name: 'Fruit' },
 *   { id: 2, name: 'Vegetable' },
 * ];
 * const products = [
 *   { name: 'Apple', categoryId: 1 },
 *   { name: 'Banana', categoryId: 1 },
 *   { name: 'Carrot', categoryId: 2 },
 * ];
 *
 * const joined = join(
 *   categories,
 *   products,
 *   c => c.id,
 *   p => p.categoryId,
 *   (c, p) => ({ category: c.name, product: p.name })
 * ).toArray();
 *
 * console.log(joined);
 * // [
 * //   { category: 'Fruit', product: 'Apple' },
 * //   { category: 'Fruit', product: 'Banana' },
 * //   { category: 'Vegetable', product: 'Carrot' }
 * // ]
 * ```
 */
export const join = <TElement, TInner, TKey, TResult>(
    source: Iterable<TElement>,
    innerEnumerable: Iterable<TInner>,
    outerKeySelector: Selector<TElement, TKey>,
    innerKeySelector: Selector<TInner, TKey>,
    resultSelector: JoinSelector<TElement, TInner, TResult>,
    keyComparator?: EqualityComparator<TKey>,
    leftJoin?: boolean
): IEnumerable<TResult> => {
    return from(source).join(from(innerEnumerable), outerKeySelector, innerKeySelector, resultSelector, keyComparator, leftJoin);
};
